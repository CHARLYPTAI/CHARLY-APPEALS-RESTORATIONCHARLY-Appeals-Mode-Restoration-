import React from 'react';
import { render, screen, waitFor, fireEvent } from '@testing-library/react';
import { describe, it, expect, vi, beforeEach, Mock } from 'vitest';\nimport { TenantSwitcher } from '../components/TenantSwitcher';\nimport { AdminUser } from '../AdminGuard';\n\n// Mock fetch for API calls\nglobal.fetch = vi.fn();\n\n// Mock localStorage\nconst mockLocalStorage = {\n  getItem: vi.fn(),\n  setItem: vi.fn(),\n  removeItem: vi.fn(),\n  clear: vi.fn(),\n};\nObject.defineProperty(window, 'localStorage', {\n  value: mockLocalStorage,\n});\n\n// Mock window.history and location\nconst mockPushState = vi.fn();\nObject.defineProperty(window, 'history', {\n  value: { pushState: mockPushState },\n});\n\nObject.defineProperty(window, 'location', {\n  value: { href: 'http://localhost/admin' },\n  writable: true,\n});\n\n// Mock window.dispatchEvent\nconst mockDispatchEvent = vi.fn();\nObject.defineProperty(window, 'dispatchEvent', {\n  value: mockDispatchEvent,\n});\n\ndescribe('TenantSwitcher Component Tests', () => {\n  beforeEach(() => {\n    vi.clearAllMocks();\n    mockLocalStorage.getItem.mockReturnValue('mock-token');\n  });\n\n  const mockTenants = [\n    {\n      type: 'RESIDENTIAL' as const,\n      userCount: 45,\n      activeUsers: 12,\n      createdAt: '2024-01-01T00:00:00Z'\n    },\n    {\n      type: 'COMMERCIAL' as const,\n      userCount: 78,\n      activeUsers: 23,\n      createdAt: '2024-01-01T00:00:00Z'\n    }\n  ];\n\n  const setupMockFetch = (tenants = mockTenants, shouldSucceed = true) => {\n    if (shouldSucceed) {\n      (fetch as Mock).mockResolvedValue({\n        ok: true,\n        json: () => Promise.resolve(tenants),\n      });\n    } else {\n      (fetch as Mock).mockRejectedValue(new Error('Failed to load tenants'));\n    }\n  };\n\n  describe('Superadmin Tenant Switching', () => {\n    const superadminUser: AdminUser = {\n      id: 'sa-1',\n      email: 'superadmin@example.com',\n      role: 'superadmin',\n      permissions: ['admin:tenants:read']\n    };\n\n    beforeEach(() => {\n      vi.doMock('../AdminGuard', () => ({\n        useAdmin: () => superadminUser,\n        hasPermission: () => true\n      }));\n      setupMockFetch();\n    });\n\n    it('should render tenant switcher dropdown for superadmin', async () => {\n      render(<TenantSwitcher />);\n      \n      const switcherButton = screen.getByLabelText('Switch tenant');\n      expect(switcherButton).toBeInTheDocument();\n      expect(switcherButton).toBeEnabled();\n    });\n\n    it('should load and display available tenants when dropdown is opened', async () => {\n      render(<TenantSwitcher />);\n      \n      const switcherButton = screen.getByLabelText('Switch tenant');\n      fireEvent.click(switcherButton);\n      \n      await waitFor(() => {\n        expect(screen.getByText('Switch Tenant Context')).toBeInTheDocument();\n        expect(screen.getByText('RESIDENTIAL')).toBeInTheDocument();\n        expect(screen.getByText('COMMERCIAL')).toBeInTheDocument();\n      });\n    });\n\n    it('should display tenant user counts and statistics', async () => {\n      render(<TenantSwitcher />);\n      \n      const switcherButton = screen.getByLabelText('Switch tenant');\n      fireEvent.click(switcherButton);\n      \n      await waitFor(() => {\n        expect(screen.getByText('45 users â€¢ 12 active')).toBeInTheDocument();\n        expect(screen.getByText('78 users â€¢ 23 active')).toBeInTheDocument();\n      });\n    });\n\n    it('should switch tenant context when option is selected', async () => {\n      render(<TenantSwitcher />);\n      \n      const switcherButton = screen.getByLabelText('Switch tenant');\n      fireEvent.click(switcherButton);\n      \n      await waitFor(() => {\n        const residentialOption = screen.getByText('RESIDENTIAL');\n        fireEvent.click(residentialOption);\n      });\n      \n      // Should update URL with tenant parameter\n      expect(mockPushState).toHaveBeenCalledWith(\n        {},\n        '',\n        expect.stringContaining('tenant=RESIDENTIAL')\n      );\n      \n      // Should dispatch tenant change event\n      expect(mockDispatchEvent).toHaveBeenCalledWith(\n        expect.objectContaining({\n          type: 'tenantChanged',\n          detail: { tenant: 'RESIDENTIAL' }\n        })\n      );\n    });\n\n    it('should close dropdown after tenant selection', async () => {\n      render(<TenantSwitcher />);\n      \n      const switcherButton = screen.getByLabelText('Switch tenant');\n      fireEvent.click(switcherButton);\n      \n      await waitFor(() => {\n        const commercialOption = screen.getByText('COMMERCIAL');\n        fireEvent.click(commercialOption);\n      });\n      \n      await waitFor(() => {\n        expect(screen.queryByText('Switch Tenant Context')).not.toBeInTheDocument();\n      });\n    });\n\n    it('should handle loading state while fetching tenants', async () => {\n      // Mock delayed response\n      (fetch as Mock).mockImplementation(() => \n        new Promise(resolve => \n          setTimeout(() => resolve({\n            ok: true,\n            json: () => Promise.resolve(mockTenants)\n          }), 100)\n        )\n      );\n      \n      render(<TenantSwitcher />);\n      \n      const switcherButton = screen.getByLabelText('Switch tenant');\n      fireEvent.click(switcherButton);\n      \n      expect(screen.getByText('Loading tenants...')).toBeInTheDocument();\n      \n      await waitFor(() => {\n        expect(screen.getByText('RESIDENTIAL')).toBeInTheDocument();\n      }, { timeout: 1000 });\n    });\n\n    it('should handle API errors when loading tenants', async () => {\n      setupMockFetch([], false);\n      \n      render(<TenantSwitcher />);\n      \n      const switcherButton = screen.getByLabelText('Switch tenant');\n      fireEvent.click(switcherButton);\n      \n      await waitFor(() => {\n        expect(screen.getByText('Failed to load tenants')).toBeInTheDocument();\n      });\n    });\n\n    it('should show current tenant in button when selected', async () => {\n      render(<TenantSwitcher />);\n      \n      // Initially should show default or \"Select Tenant\"\n      expect(screen.getByText('COMMERCIAL')).toBeInTheDocument(); // Default for superadmin\n    });\n  });\n\n  describe('Tenant Admin Fixed Scope', () => {\n    const tenantAdminUser: AdminUser = {\n      id: 'ta-1',\n      email: 'tenant.admin@example.com',\n      role: 'tenant_admin',\n      tenant_type: 'COMMERCIAL',\n      permissions: []\n    };\n\n    beforeEach(() => {\n      vi.doMock('../AdminGuard', () => ({\n        useAdmin: () => tenantAdminUser,\n        hasPermission: () => false\n      }));\n    });\n\n    it('should display read-only tenant for tenant admin', () => {\n      render(<TenantSwitcher />);\n      \n      expect(screen.getByText('COMMERCIAL')).toBeInTheDocument();\n      expect(screen.getByText('(Tenant Scope)')).toBeInTheDocument();\n      expect(screen.queryByLabelText('Switch tenant')).not.toBeInTheDocument();\n    });\n\n    it('should not make API calls for tenant list when user cannot switch', () => {\n      render(<TenantSwitcher />);\n      \n      expect(fetch).not.toHaveBeenCalled();\n    });\n\n    it('should not show dropdown arrow for tenant admin', () => {\n      render(<TenantSwitcher />);\n      \n      const tenantDisplay = screen.getByText('COMMERCIAL').closest('div');\n      expect(tenantDisplay).not.toHaveAttribute('onClick');\n    });\n  });\n\n  describe('Auditor Current View', () => {\n    const auditorUser: AdminUser = {\n      id: 'aud-1',\n      email: 'auditor@example.com',\n      role: 'auditor',\n      permissions: ['admin:tenants:read']\n    };\n\n    beforeEach(() => {\n      vi.doMock('../AdminGuard', () => ({\n        useAdmin: () => auditorUser,\n        hasPermission: () => true\n      }));\n    });\n\n    it('should display current view context for auditor', () => {\n      render(<TenantSwitcher />);\n      \n      expect(screen.getByText('(Current View)')).toBeInTheDocument();\n    });\n\n    it('should not allow tenant switching for auditor', () => {\n      render(<TenantSwitcher />);\n      \n      expect(screen.queryByLabelText('Switch tenant')).not.toBeInTheDocument();\n    });\n  });\n\n  describe('Permission-based Behavior', () => {\n    it('should not load tenants if user lacks admin:tenants:read permission', () => {\n      const limitedSuperadmin: AdminUser = {\n        id: 'sa-limited',\n        email: 'limited@example.com',\n        role: 'superadmin',\n        permissions: [] // No tenants:read permission\n      };\n      \n      vi.doMock('../AdminGuard', () => ({\n        useAdmin: () => limitedSuperadmin,\n        hasPermission: () => false\n      }));\n      \n      render(<TenantSwitcher />);\n      \n      expect(fetch).not.toHaveBeenCalled();\n    });\n\n    it('should handle user with no tenant context', () => {\n      const noContextUser: AdminUser = {\n        id: 'no-context',\n        email: 'nocontext@example.com',\n        role: 'auditor',\n        permissions: []\n      };\n      \n      vi.doMock('../AdminGuard', () => ({\n        useAdmin: () => noContextUser,\n        hasPermission: () => false\n      }));\n      \n      const { container } = render(<TenantSwitcher />);\n      \n      // Component should not render anything\n      expect(container.firstChild).toBeNull();\n    });\n  });\n\n  describe('Tenant Icons and Styling', () => {\n    const superadminUser: AdminUser = {\n      id: 'sa-1',\n      email: 'superadmin@example.com',\n      role: 'superadmin',\n      permissions: ['admin:tenants:read']\n    };\n\n    beforeEach(() => {\n      vi.doMock('../AdminGuard', () => ({\n        useAdmin: () => superadminUser,\n        hasPermission: () => true\n      }));\n      setupMockFetch();\n    });\n\n    it('should display appropriate icons for tenant types', async () => {\n      render(<TenantSwitcher />);\n      \n      const switcherButton = screen.getByLabelText('Switch tenant');\n      fireEvent.click(switcherButton);\n      \n      await waitFor(() => {\n        // Check that both tenant options are rendered\n        // Icons are implemented as SVG, so we check for the tenant text\n        expect(screen.getByText('RESIDENTIAL')).toBeInTheDocument();\n        expect(screen.getByText('COMMERCIAL')).toBeInTheDocument();\n      });\n    });\n\n    it('should show active state styling for current tenant', async () => {\n      render(<TenantSwitcher />);\n      \n      const switcherButton = screen.getByLabelText('Switch tenant');\n      fireEvent.click(switcherButton);\n      \n      await waitFor(() => {\n        // The current tenant (COMMERCIAL by default) should have active styling\n        const commercialOption = screen.getByText('COMMERCIAL').closest('button');\n        expect(commercialOption).toHaveClass('bg-blue-50');\n      });\n    });\n  });\n\n  describe('Accessibility', () => {\n    const superadminUser: AdminUser = {\n      id: 'sa-1',\n      email: 'superadmin@example.com',\n      role: 'superadmin',\n      permissions: ['admin:tenants:read']\n    };\n\n    beforeEach(() => {\n      vi.doMock('../AdminGuard', () => ({\n        useAdmin: () => superadminUser,\n        hasPermission: () => true\n      }));\n      setupMockFetch();\n    });\n\n    it('should have proper ARIA labels', () => {\n      render(<TenantSwitcher />);\n      \n      const switcherButton = screen.getByLabelText('Switch tenant');\n      expect(switcherButton).toHaveAttribute('aria-label', 'Switch tenant');\n    });\n\n    it('should support keyboard navigation', async () => {\n      render(<TenantSwitcher />);\n      \n      const switcherButton = screen.getByLabelText('Switch tenant');\n      \n      // Focus and activate with keyboard\n      switcherButton.focus();\n      fireEvent.keyDown(switcherButton, { key: 'Enter' });\n      \n      await waitFor(() => {\n        expect(screen.getByText('Switch Tenant Context')).toBeInTheDocument();\n      });\n    });\n\n    it('should have proper focus management', async () => {\n      render(<TenantSwitcher />);\n      \n      const switcherButton = screen.getByLabelText('Switch tenant');\n      fireEvent.click(switcherButton);\n      \n      await waitFor(() => {\n        // Dropdown should be focusable\n        const dropdown = screen.getByText('Switch Tenant Context').closest('div');\n        expect(dropdown).toBeInTheDocument();\n      });\n    });\n  });\n\n  describe('Error Recovery', () => {\n    const superadminUser: AdminUser = {\n      id: 'sa-1',\n      email: 'superadmin@example.com',\n      role: 'superadmin',\n      permissions: ['admin:tenants:read']\n    };\n\n    beforeEach(() => {\n      vi.doMock('../AdminGuard', () => ({\n        useAdmin: () => superadminUser,\n        hasPermission: () => true\n      }));\n    });\n\n    it('should retry loading tenants after error', async () => {\n      // First call fails, second succeeds\n      (fetch as Mock)\n        .mockRejectedValueOnce(new Error('Network error'))\n        .mockResolvedValueOnce({\n          ok: true,\n          json: () => Promise.resolve(mockTenants)\n        });\n      \n      render(<TenantSwitcher />);\n      \n      const switcherButton = screen.getByLabelText('Switch tenant');\n      fireEvent.click(switcherButton);\n      \n      await waitFor(() => {\n        expect(screen.getByText('Network error')).toBeInTheDocument();\n      });\n      \n      // Component should automatically retry or allow manual retry\n      await waitFor(() => {\n        expect(screen.getByText('RESIDENTIAL')).toBeInTheDocument();\n      }, { timeout: 2000 });\n    });\n\n    it('should handle malformed API responses gracefully', async () => {\n      (fetch as Mock).mockResolvedValue({\n        ok: true,\n        json: () => Promise.resolve({ invalid: 'response' })\n      });\n      \n      render(<TenantSwitcher />);\n      \n      const switcherButton = screen.getByLabelText('Switch tenant');\n      fireEvent.click(switcherButton);\n      \n      // Should not crash and should handle gracefully\n      await waitFor(() => {\n        expect(screen.getByText('Switch Tenant Context')).toBeInTheDocument();\n      });\n    });\n  });\n});"